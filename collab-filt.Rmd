```{r}
library(tidyverse)
library(janitor)
library(stringi)
library(Matrix)
library(rsample)

source("ingredients-rec/ingr.rec.R")
```

```{r}
df <- read_csv("outputs/facts.csv") %>%
  clean_names()
ingredients <- read_csv("outputs/ingredients.csv") %>%
  clean_names()
counts <- ingredients %>%
  count(id)
```

We will need to perform some cleaning on the ingredients field and pivot a tibble into a counts matrix.  The next two functions perform this.

```{r}
clean <- function(x) {
  x %>%
    str_remove_all("\\*.*") %>%
    str_remove("^(about|additional|accompaniments?:)\\s*") %>%
    str_remove("^an?\\s+") %>%
    str_replace_all("[-—–‑]", "-") %>%
    str_remove_all("\\(.*?\\)\\s*") %>% # parentheses
    str_remove_all("\\d+(/\\d+)?(\\.\\d+)?-?\\s*(or|to)\\s*\\d+(/\\d+)?(\\.\\d+)?[-—–]?\\s?") %>% # number to|or number
    str_remove_all("\\d+(/\\d+)?(\\.\\d+)?\\s*-\\s*\\d+(/\\d+)?(\\.\\d+)?\\s?") %>%
    str_remove_all("\\d+(/\\d+)?(\\.\\d+)?-?\\s*") %>% # number-number
    str_remove("^\\s*-?\\s*(cups?|tablespoons?|teaspoons?|grams?|ounces?|lbs?|pounds?|large|recipes?|small|oz|sticks?|inch|qt\\.|lb\\.|bags?|quarts?|gallons?|pints?|cans?) ") %>%
    str_remove("^(,\\s*)*") %>%
    str_trim()
}

prep <- function(ingredients, min_num = 1, to_mat = TRUE) {
  # replace nas with regex cleaned version
  nas <- is.na(ingredients$base)
  ingredients$marker <- nas

  ingredients[nas, "base"] <- ingredients$ingredients[nas] %>%
    clean()

  ingredients <- ingredients %>%
    mutate(base = base %>%
      stri_trans_general(id = "latin-ascii") %>%
      clean()) %>%
    filter(str_length(base) > 0)

  # remove doubles
  dups <- ingredients %>%
    with(!is.na(base) & str_detect(base, "^(.+) \\1$"))

  ingredients[dups, "base"] <- ingredients[dups, "base"] %>%
    mutate(base = str_match(base, "^(.+) \\1$")[, 2]) %>%
    pull(base)

  # combine plurals and singulars
  plurals <- ingredients %>%
    distinct(base) %>%
    filter(str_detect(base, "s$")) %>%
    mutate(s = str_match(base, "^(.*)s$")[, 2]) %>%
    filter(s %in% ingredients$base)

  plu_list <- plurals$s
  names(plu_list) <- plurals$base

  ingredients <- ingredients %>%
    mutate(base = if_else(base %in% names(plu_list), plu_list[.$base], base))

  if (!to_mat) {
    ingredients
  } else {
    ingredients %>%
      distinct(id, base) %>%
      add_count(base) %>%
      filter(n >= min_num) %>%
      select(-n) %>%
      add_count(id, base) %>%
      pivot_wider(names_from = "base", values_from = n, values_fill = 0) %>%
      select(-id) %>%
      as.matrix()
  }
}
```

We define a metric, which is the average number of missing ingredients we end up recommending.

```{r}
metric <- function(truth, pred) {
  truth %>%
    map_lgl(~ . %in% pred) %>%
    mean()
}
```

The following function tests one recipe.

```{r}
test_row <- function(model, row, pow, n = 2) {
  shuf <- row %>%
    {
      \(x) x[as.logical(x)]
    }() %>%
    names() %>%
    sample()

  y <- shuf[1:n]
  x <- shuf[n + 1:length(shuf)]

  pred <- predict(model, x, pow)$name

  metric(y, pred)
}
```

This function will create a model for a particular rsmaple fold and test every recipe in the training part of the fold.

```{r}
test_fold <- function(fold, min_num = 2, pows = 0.5) {
  # make reproducible
  set.seed(2021)

  model <- fold %>%
    analysis() %>%
    left_join(ingredients, by = "id") %>%
    prep(min_num = min_num) %>%
    create_sim()

  test <- fold %>%
    assessment() %>%
    left_join(counts, by = "id") %>%
    filter(n >= 4) %>%
    select(-n) %>%
    left_join(ingredients, by = "id") %>%
    prep()

  tibble(
    min_num = min_num,
    pows = pows,
    metric = pows %>%
      map_dbl(~ apply(test, 1, \(x) test_row(model, x, .)) %>% mean())
  )
}
```

### Cross validation

```{r}
set.seed(2021)

split <- df %>%
  initial_split()

train <- training(split)
test <- testing(split)

folds <- vfold_cv(train, v = 5)
```

For each split, we create min_num from 2 to 5 and powers from 0.1 to 1 and cross validate.

```{r}
g <- expand.grid(2:5, 1:5)

res <- map2(
  g$Var1, g$Var2,
  ~ test_fold(folds$splits[[.y]],
    min_num = .x,
    pows = c(0.1, 0.25, 0.5, 1)
  ) %>%
    mutate(split = .y)
) %>%
  bind_rows()

res %>% 
  mutate(min_num = as_factor(min_num)) %>% 
  group_by(min_num, pows) %>%
  summarize(metric = mean(metric)) %>% 
  ggplot(aes(pows, metric, color = min_num)) +
  geom_line() +
  geom_point()
```

Looks like power of 0.25 and min_num of 2 works best.

### Run model on test split to get final metric

```{r}
model <- train %>%
  left_join(ingredients, on = "id") %>% 
  prep(min_num = 2) %>%
  create_sim()

test %>% 
  left_join(ingredients, on = "id") %>% 
  prep() %>% 
  apply(1, \(x) test_row(model, x, 0.25)) %>% 
  mean()
```

### Train model on all data to use for deployment

```{r}
ingredients %>% 
  prep(min_num = 2) %>% 
  create_sim() %>% 
  saveRDS("ingredients-rec/sim.RDS")
```
